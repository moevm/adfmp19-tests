[
  {
    "id": 0,
    "color": "#1976d2",
    "name": "Java Building Blocks",
    "questions": [
      {
        "id": 0,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are valid Java identifiers? (Choose all that apply)",
        "explanation": "Option A is valid because you can use the dollar sign in identifiers. Option B is valid because you can use an underscore in identifiers. Option C is not a valid identifier because true is a Java reserved word. Option D is not valid because the dot (.) is not allowed in identifiers. Option E is valid because Java is case sensitive, so Public is not a reserved word and therefore a valid identifier. Option F is not valid because the first character is not a letter, $, or _.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A$B",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "_helloWorld",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "true",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "java.lang",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Public",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "1980_s",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 1,
        "chapterId": 0,
        "type": 1,
        "statement": "What is the output of the following program?\n1: public class WaterBottle {\n2: private String brand;\n3: private boolean empty;\n4: public static void main(String[] args) {\n5:  WaterBottle wb = new WaterBottle();\n6:   System.out.print(\"Empty = \" + wb.empty);\n7:   System.out.print(\", Brand = \" + wb.brand);\n8: } }",
        "explanation": "Boolean fields initialize to false and references initialize to null, so empty is false and brand is null. Brand = null is output.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Line 6 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Line 7 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "There is no output.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Empty = false, Brand = null",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Empty = false, Brand =",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Empty = null, Brand = null",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 2,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)\n4: short numPets = 5;\n5: int numGrains = 5.6;\n6: String name = \"Scruffy\";\n6: numPets.length();\n8: numGrains.length();\n9: name.length();",
        "explanation": "Option A (line 4) compiles because short is an integral type. Option B (line 5) generates a compiler error because int is an integral type, but 5.6 is a floating-point type. Option C (line 6) compiles because it is assigned a String. Options D and E (lines 7 and 8) do not compile because short and int are primitives. Primitives do not allow methods to be called on them. Option F (line 9) compiles because length() is defined on String.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Line 4 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Line 5 generates a compiler error.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Line 6 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Line 7 generates a compiler error.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Line 8 generates a compiler error.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Line 9 generates a compiler error.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code compiles as is.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 3,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following class, which of the following is true? (Choose all that apply)\n1: public class Snake {\n2:  public void shed(boolean time) {\n3:    if (time) {\n4:  }\n5:    System.out.println(result);\n6:  }\n7:}",
        "explanation": "Adding the variable at line 2 makes result an instance variable. Since instance variables are in scope for the entire life of the object, option A is correct. Option B is correct because adding the variable at line 4 makes result a local variable with a scope of the whole method. Adding the variable at line 6 makes result a local variable with a scope of lines 6–7. Since it is out of scope on line 8, the println does not compile and option C is incorrect. Adding the variable at line 9 makes result a local variable with a scope of lines 9 and 10. Since line 8 is before the declaration, it does not compile and option D is incorrect. Finally, option E is incorrect because the code can be made to compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "If String result = \"done\"; is inserted on line 2, the code will compile.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "If String result = \"done\"; is inserted on line 4, the code will compile.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "If String result = \"done\"; is inserted on line 6, the code will compile.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "If String result = \"done\"; is inserted on line 9, the code will compile.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above changes will make the code compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 4,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following classes, which of the following can independently replace INSERT IMPORTS HERE to make the code compile? (Choose all that apply)\n\npackage aquarium; \npublic class Tank { }\n\npackage aquarium.jellies; \npublic class Jelly { }\n\npackage visitor;\nINSERT IMPORTS HERE\npublic class AquariumVisitor {\npublic void admire(Jelly jelly) { } }",
        "explanation": "Option C is correct because it imports Jelly by classname. Option D is cor- rect because it imports all the classes in the jellies package, which includes Jelly. Option A is incorrect because it only imports classes in the aquarium package—Tank in this case—and not those in lower-level packages. Option B is incorrect because you cannot use wildcards anyplace other than the end of an import statement. Option E is incorrect because you cannot import parts of a class with a regular import statement. Option F is incorrect because options C and D do make the code compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "import aquarium.*;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "import aquarium.*.Jelly;",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "import aquarium.jellies.Jelly;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "import aquarium.jellies.*;",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "import aquarium.jellies.Jelly.*;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "None of these can make the code compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 5,
        "chapterId": 0,
        "type": 1,
        "statement": "Given the following classes, what is the maximum number of imports that can be removed and have the code still compile?\npackage aquarium; public class Water { }\n\npackage aquarium;\nimport java.lang.*;\nimport java.lang.System; \nimport aquarium.Water; \nimport aquarium.*; \npublic class Tank {\npublic void print(Water water) { \n System.out.println(water); } }",
        "explanation": "The first two imports can be removed because java.lang is automatically imported. The second two imports can be removed because Tank and Water are in the same pack- age, making the correct answer E. If Tank and Water were in different packages, one of these two imports could be removed. In that case, the answer would be option D.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "0",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "4",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "Does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 6,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following classes, which of the following snippets can be inserted in place of INSERT IMPORTS HERE and have the code compile? (Choose all that apply)\npackage aquarium;\npublic class Water {\n  boolean salty = false; \n}\npackage aquarium.jellies; public class Water {\n  boolean salty = true; \n}\npackage employee; \nINSERT IMPORTS HERE\npublic class WaterFiller { \n  Water water;\n}",
        "explanation": "Option A is correct because it imports all the classes in the aquarium package including aquarium.Water. Options B and C are correct because they import Water by classname. Since importing by classname takes precedence over wildcards, these com- pile. Option D is incorrect because Java doesn’t know which of the two wildcard Water classes to use. Option E is incorrect because you cannot specify the same classname in two imports.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "import aquarium.*;",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "import aquarium.Water;\nimport aquarium.jellies.*;",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "import aquarium.*;\nimport aquarium.jellies.Water;",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "import aquarium.*;\nimport aquarium.jellies.*;",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "import aquarium.Water;\nimport aquarium.jellies.Water;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "None of these imports can make the code compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 7,
        "chapterId": 0,
        "type": 2,
        "statement": "Given the following class, which of the following calls print out Blue Jay? (Choose all that apply)\npublic class BirdDisplay {\npublic static void main(String[] name) { \n  System.out.println(name[1]);\n}}",
        "explanation": "Option B is correct because arrays start counting from zero and strings with spaces must be in quotes. Option A is incorrect because it outputs Blue. C is incorrect because it outputs Jay. Option D is incorrect because it outputs Sparrow. Options E and F are incorrect because they output Error: Could not find or load main class Bird- Display.class.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "java BirdDisplay Sparrow Blue Jay",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "java BirdDisplay Sparrow \"Blue Jay\"",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "java BirdDisplay Blue Jay Sparrow",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "java BirdDisplay \"Blue Jay\" Sparrow",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "java BirdDisplay.class Sparrow \"Blue Jay\"",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "java BirdDisplay.class \"Blue Jay\" Sparrow",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "Does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 8,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following legally fill in the blank so you can run the main() method from the command line? (Choose all that apply)\npublic static void main(   )",
        "explanation": "Option A is correct because it is the traditional main() method signature and variables may begin with underscores. Options C and D are correct because the array operator may appear after the variable name. Option E is correct because varargs are allowed in place of an array. Option B is incorrect because variables are not allowed to begin with a digit. Option F is incorrect because the argument must be an array or varargs. Option F is a perfectly good method. However, it is not one that can be run from the command line because it has the wrong parameter type.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "String[] _names",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "String[] 123",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "String abc[]",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "String _Names[]",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "String... $n",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "String names",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 9,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are legal entry point methods that can be run from the command line? (Choose all that apply)",
        "explanation": "Option E is the canonical main() method signature. You need to memorize it. Option A is incorrect because the main() method must be public. Options B and F are incorrect because the main() method must have a void return type. Option C is incorrect because the main() method must be static. Option D is incorrect because the main() method must be named main.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "private static void main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "public static final main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public void main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "public static void test(String[] args)",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public static void main(String[] args)",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "public static main(String[] args)",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 10,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Option C is correct because all non-primitive values default to null. Option D is correct because float and double primitives default to 0.0. Options B and E are incor- rect because int primitives default to 0.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An instance variable of type double defaults to null.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "An instance variable of type int defaults to null.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An instance variable of type String defaults to null.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "An instance variable of type double defaults to 0.0.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An instance variable of type int defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An instance variable of type String defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 11,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Option G is correct because local variables do not get assigned default values. The code fails to compile if a local variable is not explicitly initialized. If this question were about instance variables, options D and F would be correct. A boolean primitive defaults to false and a float primitive defaults to 0.0.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A local variable of type boolean defaults to null.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "A local variable of type float defaults to 0.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "A local variable of type Object defaults to null.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "A local variable of type boolean defaults to false.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "A local variable of type boolean defaults to true.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "A local variable of type float defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 12,
        "chapterId": 0,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Options A and D are correct because boolean primitives default to false and int primitives default to 0.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An instance variable of type boolean defaults to false.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "An instance variable of type boolean defaults to true.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An instance variable of type boolean defaults to null.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "An instance variable of type int defaults to 0.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An instance variable of type int defaults to 0.0.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An instance variable of type int defaults to null.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "None of the above..",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 1,
    "color": "#00796b",
    "name": "Operators and Statements",
    "questions": [
      {
        "id": 13,
        "chapterId": 1,
        "type": 2,
        "statement": "Which of the following Java operators can be used with boolean variables? (Choose all that apply)",
        "explanation": "Option A is the equality operator and can be used on numeric primitives, bool- ean values, and object references. Options B and C are both arithmetic operators and cannot be applied to a boolean value. Option D is the logical complement operator and is used exclusively with boolean values. Option E is the modulus operator, which can only be used with numeric primitives. Finally, option F is a relational operator that compares the values of two numbers.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "==",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "+",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "--",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "!",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "%",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "<=",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 14,
        "chapterId": 1,
        "type": 2,
        "statement": "What data type (or types) will allow the following code snippet to compile? (Choose all that apply)\nbyte x = 5;\nbyte y = 10;\n _____ z = x + y;",
        "explanation": "The value x + y is automatically promoted to int, so int and data types that can be promoted automatically from int will work. Options A, B, D are such data types. Option C will not work because boolean is not a numeric data type. Options E and F will not work without an explicit cast to a smaller data type.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "long",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "boolean",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "double",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "short",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "byte",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 15,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following application?\n1: public class CompareValues {\n2: public static void main(String[] args) {\n3: int x = 0;\n4: while(x++ < 10) {}\n5: String message = x > 10 ? \"Greater than\" : false;\n6: System.out.println(message+\",\"+x);\n7: }\n8: }",
        "explanation": "In this example, the ternary operator has two expressions, one of them a String and the other a boolean value. The ternary operator is permitted to have expressions that don’t have matching types, but the key here is the assignment to the String reference. The compiler knows how to assign the first expression value as a String, but the sec- ond boolean expression cannot be set as a String; therefore, this line will not compile.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Greater than,10",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "false,10",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Greater than,11",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "false,11",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 16,
        "chapterId": 1,
        "type": 2,
        "statement": "What change would allow the following code snippet to compile? (Choose all that apply)\n3: long x = 10;\n4: int y = 2 * x;",
        "explanation": "The code will not compile as is, so option A is not correct. The value 2 * x is automatically promoted to long and cannot be automatically stored in y, which is in an int value. Options B, C, and D solve this problem by reducing the long value to int. Option E does not solve the problem and actually makes it worse by attempting to place the value in a smaller data type. Option F solves the problem by increasing the data type of the assignment so that long is allowed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "No change; it compiles as is.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Cast x on line 4 to int.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Change the data type of x on line 3 to short.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Cast2 * xonline4toint.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Change the data type of y on line 4 to short.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Change the data type of y on line 4 to long.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 17,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x = 4;\n4: long y = x * 4 - x++;\n5: if(y<10) System.out.println(\"Too Low\");\n6: else System.out.println(\"Just right\");\n7: else System.out.println(\"Too High\");",
        "explanation": "The code does not compile because two else statements cannot be chained together without additional if-then statements, so the correct answer is option F. Option E is incorrect as Line 6 by itself does not cause a problem, only when it is paired with Line 7. One way to fix this code so it compiles would be to add an if-then statement on line 6. The other solution would be to remove line 7.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Too Low",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Just Right",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Too High",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiles but throws a NullPointerException.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 6.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 18,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code?\n3: byte a = 40, b = 50;\n4: byte sum = (byte) a + b;\n5: System.out.println(sum);",
        "explanation": "Line 4 generates a possible loss of precision compiler error. The cast operator has the highest precedence, so it is evaluated first, casting a to a byte. Then, the addition is evaluated, causing both a and b to be promoted to int values. The value 90 is an int and cannot be assigned to the byte sum without an explicit cast, so the code does not compile. The code could be corrected with parentheses around (a + b), in which case option C would be the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "40",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "50",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "90",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An undefined value.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 19,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code?\n1: public class ArithmeticSample {\n2:  public static void main(String[] args) {\n3:   int x = 5 * 4 % 3;\n4:   System.out.println(x);\n5:} }",
        "explanation": "The * and % have the same operator precedence, so the expression is evaluated from left-to-right. The result of 5 * 4 is 20, and 20 % 3 is 2 (20 divided by 3 is 18, the remainder is 2). The output is 2 and option A is the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "6",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 20,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x = 0;\n4: String s = null;\n5: if(x == s) System.out.println(\"Success\");\n6: else System.out.println(\"Failure\");",
        "explanation": "The variable x is an int and s is a reference to a String object. The two data types are incomparable because neither variable can be converted to the other variable’s type. The compiler error occurs on line 5 when the comparison is attempted, so the answer is option D.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Success",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Failure",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 21,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x1 = 50, x2 = 75;\n4: boolean b = x1 >= x2;\n5: if(b == true) System.out.println(\"Success\");\n6: else System.out.println(\"Failure\");",
        "explanation": "The code compiles successfully, so options C and D are incorrect. The value of b after line 4 is false. However, the if-then statement on line 5 contains an assignment, not a comparison. The variable b is assigned true on line 3, and the assignment opera- tor returns true, so line 5 executes and displays Success, so the answer is option A.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Success",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "Failure",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 22,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet? 3: int c = 7;\n4: int result = 4;\n5: result += ++c;\n6: System.out.println(result);",
        "explanation": "The code compiles successfully, so option F is incorrect. On line 5, the pre-incre- ment operator is used, so c is incremented to 4 and the new value is returned to the expression. The value of result is computed by adding 4 to the original value of 8, resulting in a new value of 12, which is output on line 6. Therefore, option C is the correct answer.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "8",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "11",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "12",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "15",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "16",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 23,
        "chapterId": 1,
        "type": 1,
        "statement": "What is the output of the following code snippet?\n3: int x = 1, y = 15;\n4: while x < 10\n5:  y––;\n6:  x++;\n7: System.out.println(x+\", \"+y);",
        "explanation": "This is actually a much simpler problem than it appears to be. The while statement on line 4 is missing parentheses, so the code will not compile, and option E is the cor- rect answer. If the parentheses were added, though, option F would be the correct answer since the loop does not use curly braces to include x++ and the boolean expres- sion never changes. Finally, if curly braces were added around both expressions, the output would be 10, 6 and option B would be correct.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "10, 5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "10, 6",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "11, 5",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code contains an infinite loop and does not terminate.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 2,
    "color": "#fbc02d",
    "name": "Core Java APIs",
    "questions": [
      {
        "id": 24,
        "chapterId": 2,
        "type": 1,
        "statement": "What is output by the following code? (Choose all that apply)\n1: public class Fish {\n2:  public static void main(String[] args) {\n3:   int numFish = 4;\n4:   String fishType = \"tuna\";\n5:   String anotherFish = numFish + 1;\n6:   System.out.println(anotherFish + \" \" + fishType);\n7:   System.out.println(numFish + \" \" + 1);\n8:} }",
        "explanation": "Line 5 does not compile. This question is checking to see if you are paying attention to the types. numFish is an int and 1 is an int. Therefore, we use numeric addition and get 5. The problem is that we can’t store an int in a String variable. Supposing line 5 said String anotherFish = numFish + 1 + \"\";. In that case, the answer would be options A and D. The variable defined on line 5 would be the string \"5\", and both out- put statements would use concatenation.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "4 1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "41",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "5 tuna",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "5tuna",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "51tuna",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 25,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are output by this code? (Choose all that apply) \n3: String s = \"Hello\";\n4: String t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.equals(s)) System.out.println(\"three\"); \n8: if (\"Hello\" == s) System.out.println(\"four\"); \n9: if (\"Hello\" == t) System.out.println(\"five\");",
        "explanation": "The code compiles fine. Line 3 points to the String in the string pool. Line 4 calls the String constructor explicitly and is therefore a different object than s. Lines 5 and 7 check for object equality, which is true, and so print one and three. Line 6 uses object reference equality, which is not true since we have different objects. Line 7 also compares references but is true since both references point to the object from the string pool. Finally, line 8 compares one object from the string pool with one that was explic- itly constructed and returns false.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "one",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "two",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "three",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "four",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "five",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 26,
        "chapterId": 2,
        "type": 2,
        "statement": "Which are true statements? (Choose all that apply)",
        "explanation": "Immutable means the state of an object cannot change once it is created. Immutable objects can be garbage collected just like mutable objects. String is immu- table. StringBuilder can be mutated with methods like append(). Although StringBuffer isn’t on the exam, you should know about it anyway in case older ques- tions haven’t been removed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An immutable object can be modified.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "An immutable object cannot be modified.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "An immutable object can be garbage collected.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "An immutable object cannot be garbage collected.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "String is immutable.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "StringBuffer is immutable.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "StringBuilder is immutable.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 27,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\n7: StringBuilder sb = new StringBuilder();\n8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");\n9: System.out.println(sb);",
        "explanation": "This example uses method chaining. After the call to append(), sb contains \"aaa\". That result is passed to the first insert() call, which inserts at index 1. At this point sb contains abbbaa. That result is passed to the final insert(), which inserts at index 4, resulting in abbaccca.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "abbaaccc",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "abbaccca",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "bbaaaccc",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "bbaaccca",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 28,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\n2: String s1 = \"java\";\n3: StringBuilder s2 = new StringBuilder(\"java\"); \n4: if (s1 == s2)\n5: System.out.print(\"1\"); 6: if (s1.equals(s2))\n7: System.out.print(\"2\");",
        "explanation": "The question is trying to distract you into paying attention to logical equality versus object reference equality. It is hoping you will miss the fact that line 4 does not com- pile. Java does not allow you to compare String and StringBuilder using ==.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "12",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "No output is printed.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 29,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code? public \nclass Lion {\npublic void roar(String roar1, StringBuilder roar2) { \nroar1.concat(\"!!!\");\nroar2.append(\"!!!\");\n}\npublic static void main(String[] args) {\nString roar1 = \"roar\";\nStringBuilder roar2 = new StringBuilder(\"roar\");\nnew Lion().roar(roar1, roar2);\nSystem.out.println(roar1 + \" \" + roar2); \n}}",
        "explanation": "A String is immutable. Calling concat() returns a new String but does not change the original. A StringBuilder is mutable. Calling append() adds characters to the existing character sequence along with returning a reference to the same object.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "roar roar",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "roar roar!!!",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "roar!!! roar",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "roar!!! roar!!!",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 30,
        "chapterId": 2,
        "type": 2,
        "statement": "Which are the results of the following code? (Choose all that apply)\nString letters = \"abcdef\"; \nSystem.out.println(letters.length()); \nSystem.out.println(letters.charAt(3)); \nSystem.out.println(letters.charAt(6));",
        "explanation": "length() is simply a count of the number of characters in a String. In this case, there are six characters. charAt() returns the character at that index. Remember that indexes are zero based, which means that index 3 corresponds to d and index 6 corresponds to 1 past the end of the array. A StringIndexOutOfBoundsException is thrown for the last line.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "6",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "c",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "d",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 31,
        "chapterId": 2,
        "type": 2,
        "statement": "Which are the results of the following code? (Choose all that apply) \nString numbers = \"012345678\"; \nSystem.out.println(numbers.substring(1, 3)); \nSystem.out.println(numbers.substring(7, 7)); \nSystem.out.println(numbers.substring(7));",
        "explanation": "substring() has two forms. The first takes the index to start with and the index to stop immediately before. The second takes just the index to start with and goes to the end of the String. Remember that indexes are zero based. The first call starts at index 1 and ends with index 2 since it needs to stop before index 3. The sec- ond call starts at index 7 and ends in the same place, resulting in an empty String. This prints out a blank line. The final call starts at index 7 and goes to the end of the String.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "12",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "123",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "7",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "78",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "A blank line.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 32,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code? \n3: String s = \"purr\";\n4: s.toUpperCase();\n5: s.trim();\n6: s.substring(1, 3);\n7: s += \" two\"; \n8: System.out.println(s.length());",
        "explanation": "This question is trying to see if you know that String objects are immutable. Line 4 returns \"PURR\" but the result is ignored and not stored in s. Line 5 returns \"purr\" since there is no whitespace present but the result is again ignored. Line 6 returns \"ur\" because it starts with index 1 and ends before index 3 using zero-based indexes. The result is ignored again. Finally, on line 6 something happens. We concatenate four new characters to s and now have a String of length 8.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "8",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "10",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 33,
        "chapterId": 2,
        "type": 2,
        "statement": "What is the result of the following code? (Choose all that apply)\n13: String a = \"\"; \n14: a += 2;\n15: a += 'c';\n16: a += false;\n17: if ( a == \"2cfalse\") System.out.println(\"==\");\n18: if ( a.equals(\"2cfalse\")) System.out.println(\"equals\");",
        "explanation": "a += 2 expands to a = a + 2. A String concatenated with any other type gives a String. Lines 14, 15, and 16 all append to a, giving a result of \"2cfalse\". The if statement on line 18 returns false because the values of the two String objects are the same using object equality. The if statement on line 17 returns false because the two String objects are not the same in memory. One comes directly from the string pool and the other comes from building using String operations.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Compile error on line 14.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Compile error on line 15.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "Compile error on line 16.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compile error on another line.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "==",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "equals",
            "isCorrect": true
          },
          {
            "id": 6,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 34,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\n4: int total = 0;\n5: StringBuilder letters = new StringBuilder(\"abcdefg\");\n6: total += letters.substring(1, 2).length();\n7: total += letters.substring(6, 6).length();\n8: total += letters.substring(6, 5).length();\n9: System.out.println(total);",
        "explanation": "Line 6 adds 1 to total because substring() includes the starting index but not the ending index. Line 7 adds 0 to total. Line 8 is a problem: Java does not allow the indexes to be specified in reverse order and the code throws a StringIndexOutOf- BoundsException.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "7",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 35,
        "chapterId": 2,
        "type": 2,
        "statement": "What is the result of the following code? (Choose all that apply)\nStringBuilder numbers = new StringBuilder(\"0123456789\");\nnumbers.delete(2, 8);\nnumbers.append(\"-\").insert(2, \"+\");\nSystem.out.println(numbers);",
        "explanation": "First, we delete the characters at index 2 until the character one before index 8. At this point, 0189 is in numbers. The following line uses method chaining. It appends a dash to the end of the characters sequence, resulting in 0189–, and then inserts a plus sign at index 2, resulting in 01+89–.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "01+89–",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "012+9–",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "012+–9",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "0123456789",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 36,
        "chapterId": 2,
        "type": 1,
        "statement": "What is the result of the following code?\nStringBuilder b = \"rumble\";\nb.append(4).deleteCharAt(3).delete(3, b.length() - 1);\nSystem.out.println(b);",
        "explanation": "This is a trick question. The first line does not compile because you cannot assign a String to a StringBuilder. If that line were StringBuilder b = new StringBuilder(\"rumble\"), the code would compile and print rum4. Watch out for this sort of trick on the exam. You could easily spend a minute working out the character positions for no reason at all.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "rum",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "rum4",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "rumb4",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "rumble4",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "An exception is thrown.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 37,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of these array declarations is not legal? (Choose all that apply)",
        "explanation": "Option C uses the variable name as if it were a type, which is clearly illegal. Options E and F don’t specify any size. Although it is legal to leave out the size for later dimensions of a multidimensional array, the first one is required. Option A declares a legal 2D array. Option B declares a legal 3D array. Option D declares a legal 2D array. Remember that it is normal to see on the exam types you might not have learned. You aren’t expected to know anything about them.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "int[][] scores = new int[5][];",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Object[][][] cubbies = new Object[3][0][5];",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "String beans[] = new beans[6];",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "java.util.Date[] dates[] = new java.util.Date[2][];",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "int[][] types = new int[];",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "int[][] java = new int[][];",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 38,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "An array is not able to change size and can have multiple dimensions. Both an array and ArrayList are ordered and have indexes. Neither is immutable. The ele- ments can change in value.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "An array has a fixed size.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "An ArrayList has a fixed size.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "An array allows multiple dimensions.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "An array is ordered.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "An ArrayList is ordered.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "An array is immutable.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An ArrayList is immutable.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 39,
        "chapterId": 2,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "An array does not override equals() and so uses object equality. ArrayList does override equals() and defines it as the same elements in the same order. The compiler does not know when an index is out of bounds and thus can’t give you a compiler error. The code will throw an exception at runtime, though.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Two arrays with the same content are equal.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Two ArrayLists with the same content are equal.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "If you call remove(0) using an empty ArrayList object, it will compile successfully.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "If you call remove(0) using an empty ArrayList object, it will run successfully.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 3,
    "color": "#e64a19",
    "name": "Methods and Encapsulation",
    "questions": [
      {
        "id": 40,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following can fill in the blank in this code to make it compile? (Choose all that apply)\npublic class Ant {\n _____ void method() { }\n}",
        "explanation": "void is a return type. Only the access modifier or optional specifiers are allowed before the return type. Option C is correct, creating a method with private access. Option B is correct, creating a method with default access and the optional specifier final. Since default access does not require a modifier, we get to jump right to final.\nOption A is incorrect because default access omits the access modifier rather than spec- ifying default. Option D is incorrect because Java is case sensitive. It would have been correct if public were the choice. Option E is incorrect because the method already has a void return type. Option F is incorrect because labels are not allowed for methods.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "default",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "final",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "private",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Public",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "String",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "zzz:",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 41,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following compile? (Choose all that apply)",
        "explanation": "Options A and D are correct because the optional specifiers are allowed in any order. Options B and C are incorrect because they each have two return types. Options E and F are incorrect because the return type is before the optional specifier and access modifier, respectively.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "final static void method4() { }",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public final int void method() { }",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "private void int method() { }",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static final void method3() { }",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "void final method() {}",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "void public method() { }",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 42,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following methods compile? (Choose all that apply)",
        "explanation": "Options A and C are correct because a void method is allowed to have a return statement as long as it doesn’t try to return a value. Options B and G do not compile because null requires a reference object as the return type. void is not a refer- ence object since it is a marker for no return type. int is not a reference object since it is a primitive. Option D is correct because it returns an int value. Option E does not compile because it tries to return a double when the return type is int. Since a double cannot be assigned to an int, it cannot be returned as one either. Option F does not compile because no value is actually returned.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public void methodA() { return;}",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public void methodB() { return null;}",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public void methodD() {}",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "public int methodD() { return 9;}",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "public int methodE() { return 9.0;}",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "public int methodF() { return;}",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "public int methodG() { return null;}",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 43,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following compile? (Choose all that apply)",
        "explanation": "Options A and B are correct because the single vararg parameter is the last parameter declared. Option G is correct because it doesn’t use any vararg parameters at all. Options C and F are incorrect because the vararg parameter is not last. Option D is incorrect because two vararg parameters are not allowed in the same method. Option E is incorrect because the ... for a vararg must be after the type, not before it.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public void moreA(int... nums) {}",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "public void moreB(String values, int... nums) {}",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "public void moreC(int... nums, String values) {}",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "public void moreD(String... values, int... nums) {}",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public void moreE(String[] values, ...int nums) {}",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "public void moreF(String... values, int[] nums) {}",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "public void moreG(String[] values, int[] nums) {}",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 44,
        "chapterId": 3,
        "type": 2,
        "statement": "Given the following method, which of the method calls return 2? (Choose all that apply) \npublic int howMany(boolean b, boolean... b2) {\n  return b2.length; \n}",
        "explanation": "Option D passes the initial parameter plus two more to turn into a vararg array of size 2. Option G passes the initial parameter plus an array of size 2. Option A does not compile because it does not pass the initial parameter. Options E and F do not compile because they do not declare an array properly. It should be new boolean[] {true}. Option B creates a vararg array of size 0 and option C creates a vararg array of size 1.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "howMany();",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "howMany(true);",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "howMany(true, true);",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "howMany(true, true, true);",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "howMany(true, {true});",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "howMany(true, {true, true});",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "howMany(true, new boolean[2]);",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 45,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Option D is correct. This is the common implementation for encapsulation by set- ting all fields to be private and all methods to be public. Option A is incorrect because protected access allows everything that package private access allows and additionally allows subclasses access. Option B is incorrect because the class is public. This means that other classes can see the class. However, they cannot call any of the methods or read any of the fields. It is essentially a useless class. Option C is incorrect because package private access applies to the whole package. Option E is incorrect because Java has no such capability.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Package private access is more lenient than protected access.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "A public class that has private fields and package private methods is not visible to classes outside the package.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "You can use access modifiers so only some of the classes in a package see a particular package private class.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "You can use access modifiers to allow read access to all methods, but not any instance variables.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "You can use access modifiers to restrict read access to all classes that begin with the word Test.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 46,
        "chapterId": 3,
        "type": 2,
        "statement": "Given the following my.school.ClassRoom and my.city.School class definitions, which line numbers in main() generate a compiler error? (Choose all that apply)\n1: package my.school;\n2: public class Classroom {\n3:   private int roomNumber;\n4:   protected String teacherName;\n5:   static int globalKey = 54321;\n6:   public int floor = 3;\n7:   Classroom(int r, String t) {\n8:     roomNumber = r;\n9:     teacherName = t; } }\n\n1: package my.city;\n2: import my.school.*;\n3: public class School {\n4: public static void main(String[] args) {\n5:   System.out.println(Classroom.globalKey);\n6:   Classroom room = new Classroom(101, \"\"Mrs. Anderson\");\n7:   System.out.println(room.roomNumber);\n8:   System.out.println(room.floor);\n9:   System.out.println(room.teacherName); } }",
        "explanation": "The two classes are in different packages, which means private access and default (package private) access will not compile. Additionally, protected access will not compile since School does not inherit from Classroom. Therefore, only line 8 will compile because it uses public access.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "None, the code compiles fine.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Line 5",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Line 6",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Line 7",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Line 8",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Line 9",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 47,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following are true? (Choose all that apply)",
        "explanation": "Encapsulation requires using methods to get and set instance variables so other classes are not directly using them. Instance variables must be private for this to work. Immutability takes this a step further, allowing only getters, so the instance variables do not change state.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Encapsulation uses package private instance variables.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Encapsulation uses private instance variables.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Encapsulation allows setters.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Immutability uses package private instance variables.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Immutability uses private instance variables.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Immutability allows setters.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 48,
        "chapterId": 3,
        "type": 2,
        "statement": "Which are methods using JavaBeans naming conventions for accessors and mutators? (Choose all that apply)",
        "explanation": "Option A is incorrect because the property is of type boolean and getters must begin with is for booleans. Options B and D are incorrect because they don’t follow the naming convention of beginning with get/is/set. Options C and E follow normal getter and setter conventions.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "public boolean getCanSwim() { return canSwim;}",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "public boolean canSwim() { return numberWings;}",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public int getNumWings() { return numberWings;}",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "public int numWings() { return numberWings;}",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "public void setCanSwim(boolean b) { canSwim = b;}",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 49,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the output of the following code?\n1: package rope;\n2: public class Rope {\n3:   public static int LENGTH = 5;\n4:   static {\n5:     LENGTH = 10; \n6:   }\n7:   public static void swing() { \n8:     System.out.print(\"swing\"); \n9:   }\n10: }\n\n1: import rope.*;\n2: import static rope.Rope.*;\n3: public class Chimp {\n4:   public static void main(String[] args) {\n5:     Rope.swing();\n6:     new Rope().swing();\n7:     System.out.println(LENGTH);\n8:   }\n9: }",
        "explanation": "Rope runs line 3, setting LENGTH to 5, then immediately after runs the static initial- izer, which sets it to 10. Line 5 calls the static method normally and prints swing. Line 6 also calls the static method. Java allows calling a static method through an instance variable. Line 7 uses the static import on line 2 to reference LENGTH.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "swing swing 5",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "swing swing 10",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Compiler error on line 2 of Chimp.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Compiler error on line 5 of Chimp.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Compiler error on line 6 of Chimp.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "Compiler error on line 7 of Chimp.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 50,
        "chapterId": 3,
        "type": 2,
        "statement": "Which are true of the following code? (Choose all that apply)\n1: public class Rope {\n2:   public static void swing() {\n3:     System.out.print(\"swing\"); \n4:  }\n5:  public void climb() {\n6:    System.out.println(\"climb \");\n7:  }\n8:  public static void play() {\n9:    swing();\n10:  climb(); \n11: }\n12: public static void main(String[] args) {\n13:   Rope rope = new Rope();\n14:   rope.play();\n15:   Rope rope2 = null;\n16:   rope2.play();\n17:  }\n18: }",
        "explanation": "Line 10 does not compile because static methods are not allowed to call instance methods. Even though we are calling play() as if it were an instance method and an instance exists, Java knows play() is really a static method and treats it as such. If line 10 is removed, the code works. It does not throw a NullPointerException on line 16 because play() is a static method. Java looks at the type of the reference for rope2 and translates the call to Rope.play().",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "The code compiles as is.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "There is exactly one compiler error in the code.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "There are exactly two compiler errors in the code.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "If the lines with compiler errors are removed, the output is climb climb.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "If the lines with compiler errors are removed, the output is swing swing.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "If the lines with compile errors are removed, the code throws a NullPointerException.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 51,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the output of the following code? import rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\n  private static Rope rope1 = new Rope();\n  private static Rope rope2 = new Rope(); {\n   System.out.println(rope1.length); \n }public static void main(String[] args) { \n  rope1.length = 2;\n  rope2.length = 8;\n  System.out.println(rope1.length);\n  }\n}\n\npackage rope;\npublic class Rope {\npublic static int length = 0;\n}",
        "explanation": "There are two details to notice in this code. First, note that RopeSwing has an instance initializer and not a static initializer. Since RopeSwing is never constructed, the instance initializer does not run. The other detail is that length is static. Changes from one object update this common static variable.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "02",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "08",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "8",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 52,
        "chapterId": 3,
        "type": 1,
        "statement": "How many compiler errors are in the following code?\n1: public class RopeSwing {\n2:  private static final String leftRope;\n3:  private static final String rightRope;\n4:  private static final String bench;\n5:  private static final String name = \"name\";\n6:  static {\n7:    leftRope = \"left\";\n8:    rightRope = \"right\";\n9: }\n10: static {\n11:   name = \"name\";\n12:   rightRope = \"right\";\n13: }\n14: public static void main(String[] args) {\n15:   bench = \"bench\";\n16: }\n17: }",
        "explanation": "static final variables must be set exactly once, and it must be in the declaration line or in a static initialization block. Line 4 doesn’t compile because bench is not set in either of these locations. Line 15 doesn’t compile because final variables are not allowed to be set after that point. Line 11 doesn’t compile because name is set twice: once in the declaration and again in the static block. Line 12 doesn’t compile because rightRope is set twice as well. Both are in static initialization blocks.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "0",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "2",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "3",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "4",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "5",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 53,
        "chapterId": 3,
        "type": 2,
        "statement": "Which of the following can replace line 2 to make this code compile? (Choose all that apply)\n1: import java.util.*;\n2: // INSERT CODE HERE\n3: public class Imports {\n4:  public void method(ArrayList<String> list) {\n5:   sort(list);\n6:  }\n7: }",
        "explanation": "The two valid ways to do this are import static java.util.Collections.*; and import static java.util.Collections.sort;. Option A is incorrect because you can only do a static import on static members. Classes such as Collections require a regular import. Option C is nonsense as method parameters have no business in an import. Options D, E, and F try to trick you into reversing the syntax of import static.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "import static java.util.Collections;",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "import static java.util.Collections.*;",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "import static java.util.Collections.sort(ArrayList<String>);",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static import java.util.Collections;",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "static import java.util.Collections.*;",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "static import java.util.Collections.sort(ArrayList<String>);",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 54,
        "chapterId": 3,
        "type": 1,
        "statement": "What is the result of the following statements?\n1: public class Test {\n2:   public void print(byte x) {\n3:     System.out.print(\"byte\");\n4:   }\n5:   public void print(int x) {\n6:     System.out.print(\"int\");\n7:   }\n8:   public void print(float x) {\n9:     System.out.print(\"float\");\n10:  }\n11:  public void print(Object x) {\n12:    System.out.print(\"Object\");\n13:  }\n14:  public static void main(String[] args) {\n15:    Test t = new Test();\n16:    short s = 123;\n17:    t.print(s);\n18:    t.print(true);\n19:    t.print(6.789);\n20:   }\n21: }",
        "explanation": "The argument on line 17 is a short. It can be promoted to an int, so print() on line 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a bool- ean, so print() on line 11 is invoked. The argument on line 19 is a double. It can be autoboxed to a double, so print() on line 11 is invoked. Therefore, the output is intObjectObject and the correct answer is option E.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "bytefloatObject",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "intfloatObject",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "byteObjectfloat",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "intObjectfloat",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "intObjectObject",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "byteObjectObject",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 4,
    "color": "#607d8b",
    "name": "Class Design",
    "questions": [
      {
        "id": 55,
        "chapterId": 4,
        "type": 2,
        "statement": "What modifiers are implicitly applied to all interface methods? (Choose all that apply)",
        "explanation": "All interface methods are implicitly public, so option B is correct and option A is not. Interface methods may be declared as static or default but are never implicitly added, so options C and F are incorrect. Option D is incorrect—void is not a modifier; it is a return type. Option E is a tricky one, because prior to Java 8 all interface meth- ods would be assumed to be abstract. Since Java 8 now includes default and static methods and they are never abstract, you cannot assume the abstract modifier will be implicitly applied to all methods by the compiler.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "protected",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "public",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "static",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "void",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "abstract",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "default",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 56,
        "chapterId": 4,
        "type": 1,
        "statement": "What is the output of the following code?\n1: class Mammal {\n2:   public Mammal(int age) {\n3:     System.out.print(\"Mammal\");\n4:   }\n5: }\n6: public class Platypus extends Mammal {\n7:   public Platypus() {\n8:     System.out.print(\"Platypus\");\n9:   }\n10:  public static void main(String[] args) {\n11:    new Mammal(5);\n12:  }\n13: }",
        "explanation": "The code will not compile because the parent class Mammal doesn’t define a no-argu- ment constructor, so the first line of a Platypus constructor should be an explicit call to super(int age). If there was such a call, then the output would be MammalPlatypus, since the super constructor is executed before the child constructor.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Platypus",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Mammal",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "PlatypusMammal",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "MammalPlatypus",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of line 8.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code will not compile because of line 11.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 57,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following statements can be inserted in the blank line so that the code will compile successfully? (Choose all that apply)\npublic interface CanHop {}\npublic class Frog implements CanHop {\n  public static void main(String[] args) {\n    __________ frog = new TurtleFrog();\n  }\n}\npublic class BrazilianHornedFrog extends Frog {}\npublic class TurtleFrog extends Frog {}",
        "explanation": "The blank can be filled with any class or interface that is a supertype of TurtleFrog. Option A is a superclass of TurtleFrog, and option B is the same class, so both are correct. BrazilianHornedFrog is not a superclass of TurtleFrog, so option C is incorrect. TurtleFrog inherits the CanHope interface, so option D is correct. All classes inherit Object, so option E is correct. Finally, Long is an unrelated class that is not a superclass of TurtleFrog, and is therefore incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Frog",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "TurtleFrog",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "BrazilianHornedFrog",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "CanHop",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "Object",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Long",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 58,
        "chapterId": 4,
        "type": 2,
        "statement": "Which statement(s) are correct about the following code? (Choose all that apply)\npublic class Rodent {\n  protected static Integer chew() throws Exception {\n    System.out.println(\"Rodent is chewing\");\n    return 1;\n  }\n}\npublic class Beaver extends Rodent {\n  public Number chew() throws RuntimeException {\n    System.out.println(\"Beaver is chewing on wood\");\n    return 2;\n  }\n}",
        "explanation": "The code doesn’t compile, so option A is incorrect. Option B is also not correct because the rules for overriding a method allow a subclass to define a method with an exception that is a subclass of the exception in the parent method. Option C is cor- rect because the return types are not covariant; in particular, Number is not a subclass of Integer. Option D is incorrect because the subclass defines a method that is more accessible than the method in the parent class, which is allowed. Finally, option E is correct because the method is declared as static in the parent class and not so in the child class. For nonprivate methods in the parent class, both methods must use static (hide) or neither should use static (override).",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It will compile without issue.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "It fails to compile because the type of the exception the method throws is a subclass of the type of exception the parent method throws.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "It fails to compile because the return types are not covariant.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "It fails to compile because the method is protected in the parent class and public in the subclass.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "It fails to compile because of a static modifier mismatch between the two methods.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 59,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following may only be hidden and not overridden? (Choose all that apply)",
        "explanation": "First off, options B and C are incorrect because protected and public meth- ods may be overridden, not hidden. Option A is correct because private methods are always hidden in a subclass. Option D is also correct because static methods cannot be overridden, only hidden. Options E and F are correct because variables may only be hidden, regardless of the access modifier.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "private instance methods",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "protected instance methods",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "public instance methods",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "static methods",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "public variables",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "private variables",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 60,
        "chapterId": 4,
        "type": 1,
        "statement": "Choose the correct statement about the following code:\n1: interface HasExoskeleton {\n2: abstract int getNumberOfSections();\n3: }\n4: abstract class Insect implements HasExoskeleton {\n5: abstract int getNumberOfLegs();\n6: }\n7: public class Beetle extends Insect {\n8: int getNumberOfLegs() { return 6; }\n9: }",
        "explanation": "The code fails to compile because Beetle, the first concrete subclass, doesn’t imple- ment getNumberOfSections(), which is inherited as an abstract method; therefore, option D is correct. Option B is incorrect because there is nothing wrong with this interface method definition. Option C is incorrect because an abstract class is not required to implement any abstract methods, including those inherited from an inter- face. Option E is incorrect because the code fails at compilation-time.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It compiles and runs without issue.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 7.",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "It compiles but throws an exception at runtime.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 61,
        "chapterId": 4,
        "type": 2,
        "statement": "Which of the following statements about polymorphism are true? (Choose all that apply)",
        "explanation": "A reference to an object requires an explicit cast if referenced with a subclass, so option A is incorrect. If the cast is to a superclass reference, then an explicit cast is not required. Because of polymorphic parameters, if a method takes the superclass of an object as a parameter, then any subclass references may be used without a cast, so option B is correct. All objects extend java.lang.Object, so if a method takes that type, any valid object, including null, may be passed; therefore, option C is correct. Some cast exceptions can be detected as errors at compile-time, but others can only be detected at runtime, so D is incorrect. Due to the nature of polymorphism, a public instance method can be overridden in a subclass and calls to it will be replaced even in the superclass it was defined, so E is incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "A reference to an object may be cast to a subclass of the object without an explicit cast.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "If a method takes a superclass of three objects, then any of those classes may be passed as a parameter to the method.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "A method that takes a parameter with type java.lang.Object will take any reference.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "All cast exceptions can be detected at compile-time.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "By defining a public instance method in the superclass, you guarantee that the specific method will be called in the parent class at runtime.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 62,
        "chapterId": 4,
        "type": 1,
        "statement": "Choose the correct statement about the following code:\n1: public interface Herbivore {\n2:   int amount = 10;\n3:   public static void eatGrass();\n4:   public int chew() {\n5:     return 13;\n6:   }\n7: }",
        "explanation": "The interface variable amount is correctly declared, with public and static being assumed and automatically inserted by the compiler, so option B is incorrect. The method declaration for eatGrass() on line 3 is incorrect because the method has been marked as static but no method body has been provided. The method declaration for chew() on line 4 is also incorrect, since an interface method that provides a body must be marked as default or static explicitly. Therefore, option F is the correct answer since this code contains two compile-time errors.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It compiles and runs without issue.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 3.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of lines 2 and 3.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because of lines 3 and 4.",
            "isCorrect": true
          }
        ]
      },
      {
        "id": 63,
        "chapterId": 4,
        "type": 1,
        "statement": "Choose the correct statement about the following code:\n1: public interface CanFly {\n2:   void fly();\n3: }\n4: interface HasWings {\n5:   public abstract Object getWindSpan();\n6: }\n7: abstract class Falcon implements CanFly, HasWings {\n8: }",
        "explanation": "Although the definition of methods on lines 2 and 5 vary, both will be converted to public abstract by the compiler. Line 4 is fine, because an interface can have pub- lic or default access. Finally, the class Falcon doesn’t need to implement the interface methods because it is marked as abstract. Therefore, the code will compile without issue.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It compiles without issue.",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "The code will not compile because of line 2.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "The code will not compile because of line 4.",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "The code will not compile because of line 5.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code will not compile because of lines 2 and 5.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code will not compile because the class Falcon doesn’t implement the interface methods.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 64,
        "chapterId": 4,
        "type": 2,
        "statement": "Which statements are true for both abstract classes and interfaces? (Choose all that apply)",
        "explanation": "Option A is wrong, because an abstract class may contain concrete meth- ods. Since Java 8, interfaces may also contain concrete methods in form of static or default methods. Although all variables in interfaces are assumed to be public static final, abstract classes may contain them as well, so option B is correct. Both abstract classes and interfaces can be extended with the extends keyword, so option C is cor- rect. Only interfaces can contain default methods, so option D is incorrect. Both abstract classes and interfaces can contain static methods, so option E is correct. Both structures require a concrete subclass to be instantiated, so option F is correct. Finally, though an instance of an object that implements an interface inherits java.lang. Object, the interface itself doesn’t; otherwise, Java would support multiple inheritance for objects, which it doesn’t. Therefore, option G is incorrect.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "All methods within them are assumed to be abstract.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Both can contain public static final variables.",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Both can be extended using the extend keyword.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "Both can contain default methods.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "Both can contain static methods.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "Neither can be instantiated directly.",
            "isCorrect": true
          },
          {
            "id": 6,
            "answer": "Both inherit java.lang.Object.",
            "isCorrect": false
          }
        ]
      }
    ]
  },
  {
    "id": 5,
    "color": "#7b1fa2",
    "name": "Exceptions",
    "questions": [
      {
        "id": 65,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following pairs fill in the blanks to make this code compile? (Choose all that apply)\n7: public void ohNo() _____ Exception {\n8: _____________ Exception();\n 9: }",
        "explanation": "In a method declaration, the keyword throws is used. To actually throw an exception, the keyword throw is used and a new exception is created.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "On line 7, fill in throw",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "On line 7, fill in throws",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "On line 8, fill in throw",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "On line 8, fill in throw new",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "On line 8, fill in throws",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "On line 8, fill in throws new",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 66,
        "chapterId": 5,
        "type": 1,
        "statement": "When are you required to use a finally block in a regular try statement (not a try-with- resources)?",
        "explanation": "A try statement is required to have a catch clause and/or finally clause. If it goes the catch route, it is allowed to have multiple catch clauses.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Never",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "When the program code doesn’t terminate on its own.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "When there are no catch blocks in a try statement.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "When there is exactly one catch block in a try statement.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "When there are two or more catch blocks in a try statement.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 67,
        "chapterId": 5,
        "type": 2,
        "statement": "Which exception will the following throw?\nObject obj = new Integer(3);\nString str = (String) obj;\nSystem.out.println(str);",
        "explanation": "The second line tries to cast an Integer to a String. Since String does not extend Integer, this is not allowed and a ClassCastException is thrown.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "ArrayIndexOutOfBoundsException",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "ClassCastException",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "IllegalArgumentException",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "NumberFormatException",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 68,
        "chapterId": 5,
        "type": 2,
        "statement": "Which of the following exceptions are thrown by the JVM? (Choose all that apply)",
        "explanation": "java.io.IOException is thrown by many methods in the java.io package, but it is always thrown programmatically. The same is true for NumberFormatExcep- tion; it is thrown programmatically by the wrapper classes of java.lang. The other three exceptions are all thrown by the JVM when the corresponding problem arises.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "ArrayIndexOutOfBoundsException",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "ExceptionInInitializerError",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "java.io.IOException",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "NullPointerException",
            "isCorrect": true
          },
          {
            "id": 4,
            "answer": "NumberFormatException",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 69,
        "chapterId": 5,
        "type": 1,
        "statement": "What will happen if you add the statement System.out.println(5 / 0); to a working main() method?",
        "explanation": "The compiler tests the operation for a valid type but not a valid result, so the code will still compile and run. At runtime, evaluation of the parameter takes place before passing it to the print() method, so an ArithmeticException object is raised.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "It will not compile.",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "It will not run.",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "It will run and throw an ArithmeticException.",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "It will run and throw an IllegalArgumentException.",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "None of the above.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 70,
        "chapterId": 5,
        "type": 1,
        "statement": "What is printed besides the stack trace caused by the NullPointerException from line 16?\n1: public class DoSomething {\n2:   public void go() {\n3:     System.out.print(\"A\");\n4:     try {\n5:       stop();\n6:     } catch (ArithmeticException e) {\n7:       System.out.print(\"B\");\n8:     } finally {\n9:       System.out.print(\"C\");\n10:    }\n11:    System.out.print(\"D\");\n12:  }\n13:  public void stop() {\n14:    System.out.print(\"E\");\n15:    Object x = null;\n16:    x.toString();\n17:    System.out.print(\"F\");\n18:  }\n19:  public static void main(String[] args) {\n20:    new DoSomething().go();\n21:  }\n22: }",
        "explanation": "The main() method invokes go and A is printed on line 3. The stop method is invoked and E is printed on line 14. Line 16 throws a NullPointerException, so stop immediately ends and line 17 doesn’t execute. The exception isn’t caught in go, so the go method ends as well, but not before its finally block executes and C is printed on line 9. Because main() doesn’t catch the exception, the stack trace displays and no fur- ther output occurs, so AEC was the output printed before the stack trace.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "AE",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "AEBCD",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "AEC",
            "isCorrect": true
          },
          {
            "id": 3,
            "answer": "AECD",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "No output appears other than the stack trace.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 71,
        "chapterId": 5,
        "type": 1,
        "statement": "What is the output of the following snippet, assuming a and b are both 0?\n3: try {\n4:   return a / b;\n5: } catch (RuntimeException e) {\n6:   return -1;\n7: } catch (ArithmeticException e) {\n8:   return 0;\n9: } finally {\n10:  System.out.print(\"done\");\n11: }",
        "explanation": "The order of catch blocks is important because they’re checked in the order they appear after the try block. Because ArithmeticException is a child class of Runtime- Exception, the catch block on line 7 is unreachable. (If an ArithmeticException is thrown in try try block, it will be caught on line 5.) Line 7 generates a compiler error because it is unreachable code.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "-1",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "0",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "done-1",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "done0",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "An uncaught exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 72,
        "chapterId": 5,
        "type": 2,
        "statement": "What is the output of the following program?\n1: public class Laptop { \n2:   public void start() {\n3:     try {\n4:       System.out.print(\"Starting up \");\n5:       throw new Exception();\n6:     } catch (Exception e) {\n7:       System.out.print(\"Problem \");\n8:       System.exit(0);\n9:     } finally {\n10:      System.out.print(\"Shutting down \");\n11:    }\n12:   }\n13:   public static void main(String[] args) {\n14:     new Laptop().start();\n15: } }",
        "explanation": "The main() method invokes start on a new Laptop object. Line 4 prints Starting up; then line 5 throws an Exception. Line 6 catches the exception, line 7 prints Problem, and then line 8 calls System.exit, which terminates the JVM. The finally block does not execute because the JVM is no longer running.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "Starting up",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "Starting up Problem",
            "isCorrect": true
          },
          {
            "id": 2,
            "answer": "Starting up Problem Shutting down",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "Starting up Shutting down",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "An uncaught exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 73,
        "chapterId": 5,
        "type": 1,
        "statement": "What is the output of the following program?\n1: public class Dog {\n2:   public String name;\n3:   public void parseName() {\n4:     System.out.print(\"1\");\n5:     try {\n6:       System.out.print(\"2\");\n7:       int x = Integer.parseInt(name);\n8:       System.out.print(\"3\");\n9:     } catch (NumberFormatException e) {\n10:      System.out.print(\"4\");\n11:    }\n12:   }\n13:   public static void main(String[] args) {\n14:     Dog leroy = new Dog();\n15:     leroy.name = \"Leroy\"\n16:     leroy.parseName();\n17:     System.out.print(\"5\")\n18: } }",
        "explanation": "The parseNamemethod is invoked within main() on a newDog object.Line4 prints 1. The try block executes and 2 is printed. Line 7 throws a NumberFormatException, so line 8 doesn’t execute. The exception is caught on line 9, and line 10 prints 4. Because the exception is handled, execution resumes normally. parseName runs to completion, and line 17 executes, printing 5. That’s the end of the program, so the output is 1245.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "12",
            "isCorrect": false
          },
          {
            "id": 1,
            "answer": "1234",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "1235",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "124",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "1245",
            "isCorrect": true
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An uncaught exception is thrown.",
            "isCorrect": false
          }
        ]
      },
      {
        "id": 74,
        "chapterId": 5,
        "type": 2,
        "statement": "What is the output of the following program?\n1: public class Cat {\n2:   public String name;\n3:   public void parseName() {\n4:     System.out.print(\"1\");\n5:     try {\n6:       System.out.print(\"2\");\n7:       int x = Integer.parseInt(name);\n8:       System.out.print(\"3\");\n9:     } catch (NullPointerException e) {\n10:      System.out.print(\"4\");\n11:    }\n12:    System.out.print(\"5\");\n13:  }\n14:  public static void main(String[] args) {\n15:    Cat leo = new Cat();\n16:    leo.name = \"Leo\";\n17:    leo.parseName();\n18:    System.out.print(\"6\");\n19:  }\n20: }",
        "explanation": "The parseName method is invoked on a new Cat object. Line 4 prints 1. The try block is entered, and line 6 prints 2. Line 7 throws a NumberFormatException. It isn’t caught, so parseName ends. main() doesn’t catch the exception either, so the program terminates and the stack trace for the NumberFormatException is printed.",
        "isFavorite": false,
        "answers": [
          {
            "id": 0,
            "answer": "12, followed by a stack trace for a NumberFormatException",
            "isCorrect": true
          },
          {
            "id": 1,
            "answer": "124, followed by a stack trace for a NumberFormatException",
            "isCorrect": false
          },
          {
            "id": 2,
            "answer": "12456",
            "isCorrect": false
          },
          {
            "id": 3,
            "answer": "12456",
            "isCorrect": false
          },
          {
            "id": 4,
            "answer": "1256, followed by a stack trace for a NumberFormatException",
            "isCorrect": false
          },
          {
            "id": 5,
            "answer": "The code does not compile.",
            "isCorrect": false
          },
          {
            "id": 6,
            "answer": "An uncaught exception is thrown",
            "isCorrect": false
          }
        ]
      }
    ]
  }
]